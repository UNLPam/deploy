			   to this object.  This level of coupling may, however, be			   undesirable since it could result in an only partially populated collection			   in the referenced object.			   $this->aTeacher->addCourseSubjectTeachers($this);			 */		}		return $this->aTeacher;	}	/**	 * Declares an association between this object and a CourseSubject object.	 *	 * @param      CourseSubject $v	 * @return     CourseSubjectTeacher The current object (for fluent API support)	 * @throws     PropelException	 */	public function setCourseSubject(CourseSubject $v = null)	{		if ($v === null) {			$this->setCourseSubjectId(NULL);		} else {			$this->setCourseSubjectId($v->getId());		}		$this->aCourseSubject = $v;		// Add binding for other direction of this n:n relationship.		// If this object has already been added to the CourseSubject object, it will not be re-added.		if ($v !== null) {			$v->addCourseSubjectTeacher($this);		}		return $this;	}	/**	 * Get the associated CourseSubject object	 *	 * @param      PropelPDO Optional Connection object.	 * @return     CourseSubject The associated CourseSubject object.	 * @throws     PropelException	 */	public function getCourseSubject(PropelPDO $con = null)	{		if ($this->aCourseSubject === null && ($this->course_subject_id !== null)) {			$c = new Criteria(CourseSubjectPeer::DATABASE_NAME);			$c->add(CourseSubjectPeer::ID, $this->course_subject_id);			$this->aCourseSubject = CourseSubjectPeer::doSelectOne($c, $con);			/* The following can be used additionally to			   guarantee the related object contains a reference			   to this object.  This level of coupling may, however, be			   undesirable since it could result in an only partially populated collection			   in the referenced object.			   $this->aCourseSubject->addCourseSubjectTeachers($this);			 */		}		return $this->aCourseSubject;	}	/**	 * Declares an association between this object and a Situation_R object.	 *	 * @param      Situation_R $v	 * @return     CourseSubjectTeacher The current object (for fluent API support)	 * @throws     PropelException	 */	public function setSituation_R(Situation_R $v = null)	{		if ($v === null) {			$this->setSituationRId(NULL);		} else {			$this->setSituationRId($v->getId());		}		$this->aSituation_R = $v;		// Add binding for other direction of this n:n relationship.		// If this object has already been added to the Situation_R object, it will not be re-added.		if ($v !== null) {			$v->addCourseSubjectTeacher($this);		}		return $this;	}	/**	 * Get the associated Situation_R object	 *	 * @param      PropelPDO Optional Connection object.	 * @return     Situation_R The associated Situation_R object.	 * @throws     PropelException	 */	public function getSituation_R(PropelPDO $con = null)	{		if ($this->aSituation_R === null && ($this->situation_r_id !== null)) {			$c = new Criteria(Situation_RPeer::DATABASE_NAME);			$c->add(Situation_RPeer::ID, $this->situation_r_id);			$this->aSituation_R = Situation_RPeer::doSelectOne($c, $con);			/* The following can be used additionally to			   guarantee the related object contains a reference			   to this object.  This level of coupling may, however, be			   undesirable since it could result in an only partially populated collection			   in the referenced object.			   $this->aSituation_R->addCourseSubjectTeachers($this);			 */		}		return $this->aSituation_R;	}	/**	 * Resets all collections of referencing foreign keys.
	 *	 * This method is a user-space workaround for PHP's inability to garbage collect objects	 * with circular references.  This is currently necessary when using Propel in certain	 * daemon or large-volumne/high-memory operations.	 *	 * @param      boolean $deep Whether to also clear the references on all associated objects.	 */	public function clearAllReferences($deep = false)	{		if ($deep) {		} // if ($deep)			$this->aTeacher = null;			$this->aCourseSubject = null;			$this->aSituation_R = null;	}  public function __call($method, $arguments)  { 